use std::collections::HashMap;
use common::ast::{AstNode, Type, TypedValue};
use crate::frontend::lexer::{Token, TokenType};

/// Struct representing a parser that generates an Abstract Syntax Tree (AST)
/// from a list of Tokens generated by the lexer
pub struct Parser {
    /// A list of tokens representing a file
    tokens: Vec<Token>,
    /// Represents the current position in the above token list
    pos: usize,
}

fn ident_to_type(ident: String) -> Type {
    return match ident.as_str() {
        "bool" => Type::Boolean,
        "int" => Type::Int,
        "float" => Type::Float,
        "String" => Type::String,
        "null" => Type::Null,
        _ => Type::Reference
    }
}

fn can_convert_f64(value: &f64) -> bool {
    // Check if the value is within the range of i64
    value >= &(i64::MIN as f64) && value <= &(i64::MAX as f64) &&
    value.fract() == 0.0 //Check if the value is an integer (has no fractional part)
}

/// Implementation for the Parser struct.
impl Parser {
    pub fn new(
        tokens: Vec<Token>,
    ) -> Self {
        Parser {
            tokens,
            pos: 0,
        }
    }

    pub fn parse(&mut self) -> AstNode {
        let mut body = Vec::new();

        while let Some(token) = self.next() {
            match &token.token_type {
                TokenType::Func => {
                    if let Some(func_node) = self.enter_func_declaration() {
                        body.push(func_node);
                    }
                }
                TokenType::Identifier(_) => {
                    if let Some(expr) = self.parse_expr() {
                        body.push(expr);
                    }
                }
                _ => {
                    panic!("Token type not implemented: {:?}", &token.token_type)
                }
            }
        }

        AstNode::Document {
            body: Box::new(AstNode::Block {
                body,
            }),
        }
    }

    fn parse_expr(&mut self) -> Option<AstNode> {
        if let Some(token) = self.get() {
            match &token.token_type {
                TokenType::Identifier(_) => {
                    if let Some(token) = self.next() {
                        match &token.token_type {
                            // variable declaration
                            TokenType::Identifier(var_name) => {
                                if let Some(token) = self.next() {
                                    match &token.token_type {
                                        TokenType::Eq => {
                                            if let Some(val) = self.next() {
                                                return match &val.token_type {
                                                    // reference
                                                    TokenType::Identifier(reference) => {
                                                        Some(AstNode::VarDeclaration {
                                                            name: var_name.clone(),
                                                            is_mutable: false,
                                                            is_static: false,
                                                            value: TypedValue::ReferenceVal(reference.clone()),
                                                        })
                                                    },
                                                    // strings
                                                    TokenType::StringLiteral(lit) => {
                                                        Some(AstNode::VarDeclaration {
                                                            name: var_name.clone(),
                                                            is_mutable: false,
                                                            is_static: false,
                                                            value: TypedValue::StringVal(lit.clone()),
                                                        })
                                                    },
                                                    // booleans
                                                    TokenType::BoolLiteral(lit) => {
                                                        Some(AstNode::VarDeclaration {
                                                            name: var_name.clone(),
                                                            is_mutable: false,
                                                            is_static: false,
                                                            value: TypedValue::BoolVal(lit.clone()),
                                                        })
                                                    },
                                                    // integers
                                                    TokenType::IntLiteral(lit) => {
                                                        if can_convert_f64(lit) {
                                                            // integer
                                                            Some(AstNode::VarDeclaration {
                                                                name: var_name.clone(),
                                                                is_mutable: false,
                                                                is_static: false,
                                                                value: TypedValue::IntVal(lit.clone() as i64),
                                                            })
                                                        } else {
                                                            // float
                                                            Some(AstNode::VarDeclaration {
                                                                name: var_name.clone(),
                                                                is_mutable: false,
                                                                is_static: false,
                                                                value: TypedValue::FloatVal(lit.clone()),
                                                            })
                                                        }
                                                    },
                                                    // null
                                                    TokenType::NullLiteral => {
                                                        Some(AstNode::VarDeclaration {
                                                            name: var_name.clone(),
                                                            is_mutable: false,
                                                            is_static: false,
                                                            value: TypedValue::NullVal,
                                                        })
                                                    },
                                                    // unknown value, user error
                                                    _ => None
                                                }
                                            }
                                        },
                                        // not a variable declaration
                                        _ => return None
                                    }
                                }
                            },
                            // unrecognised
                            _ => return None
                        }
                    }
                },
                _ => return None
            }
        }

        None
    }

    fn enter_func_declaration(&mut self) -> Option<AstNode> {
        if let Some(token) = self.next() {
            match &token.token_type {
                TokenType::Identifier(func_name) => {
                    if let Some(params) = self.enter_func_params() {
                        if let Some(body) = self.enter_func_body() {
                            return Some(AstNode::FuncDeclaration {
                                name: func_name.clone(),
                                params,
                                returns: Type::Void,
                                body: Box::new(body),
                            })
                        }
                    }
                }
                _ => return None
            }
        }

        None
    }

    fn enter_func_params(&mut self) -> Option<HashMap<String, Type>> {
        let mut params = HashMap::new();

        if let Some(token) = self.next() {
            match &token.token_type {
                TokenType::LParen => {
                    while let Some(token) = self.next() {
                        match &token.token_type {
                            TokenType::RParen => return Some(params),
                            TokenType::Identifier(type_ident) => {
                                if let Some(token) = self.next() {
                                    match &token.token_type {
                                        TokenType::Identifier(param_ident) => {
                                            params.insert(param_ident.clone(), ident_to_type(type_ident.clone()));
                                        },
                                        _ => return None
                                    }
                                }
                            }
                            _ => return None
                        }
                    }
                },

                _ => return None
            }
        }

        None
    }

    fn enter_func_body(&mut self) -> Option<AstNode> {
        let mut body = vec![];

        if let Some(token) = self.next() {
            match &token.token_type {
                // open func body
                TokenType::LBrace => {
                    while let Some(token) = self.next() {
                        match &token.token_type {
                            // close func body
                            TokenType::RBrace => {
                                return Some(AstNode::Block {
                                    body,
                                })
                            }
                            // fill func body
                            _ => {
                                if let Some(expr) = self.parse_expr() {
                                    body.push(expr);
                                } else {
                                    return None
                                }
                            }
                        }
                    }
                }
                _ => return None
            }
        }

        None
    }

    fn peek(&mut self) -> Option<Token> {
        if let Some(token) = self.tokens.get(self.pos + 1) {
            return Some(token.clone())
        }

        None
    }

    fn get(&mut self) -> Option<Token> {
        if let Some(token) = self.tokens.get(self.pos) {
            return Some(token.clone())
        }

        None
    }

    fn next(&mut self) -> Option<Token> {
        if self.pos == 0 {
            if let Some(token) = self.tokens.get(0) {
                self.pos += 1;
                return Some(token.clone());
            }
        }

        if let Some(token) = self.get() {
            self.pos += 1;
            return Some(token);
        }

        None
    }
}